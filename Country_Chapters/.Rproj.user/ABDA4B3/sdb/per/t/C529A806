{
    "contents" : "#########################################################################\n### Title:  Access PCDB on HU-server, read data from tables and view,\n###          and create lists with variable codes and descriptive labels\n###\n### Author: Hauke Licht (HL)\n### Date:   August 25, 2016\n### produced under R version 3.2.3\n\n### Comment: (HL) This code produces a cache'd file that is then used in ui.R and server.R to render the RShiny app; \n###           To foreclose this code from public visibility in the GitHub repos, it is placed in the git-ignore folders \n###           But then the  p a t h s  u s e d   i n   t h i s   c o d e   n e e d   t o   b e  c h a n g e d  accordingly! \n\n\nif (!require('needs')) install.packages(\"needs\")\nneeds(RPostgreSQL,dplyr,countrycode,R.cache)\n\n# Set path to local 'vaps-dashboard_public' directory \nif ( Sys.info()[\"user\"] == \"lichthau\" ) { path <- \"~/Documents/Humboldt/Electoral_Vulnerability/Projects/vaps-dashboard_public\"\n} else if ( Sys.info()[\"user\"] == \"johndoe\" ) { path <- \"\"\n} else if ( Sys.info()[\"user\"] == \"mio-mio1\" ) {   path <- \"\"\n} else warning(\"Sorry, but could not find path to 'vaps-dashboard_public' directory.\")\n\n\nif ( sub(\".*/\",\"\",getwd()) != \"vaps-dashboard_public\" ) setwd(path) ## set path to vaps-dashboard_public here ##\nrm(path)\n\n# (1) Connect to Database\n\n  # define parameters as object\n  dbname <- \"polconfdb\"\n  dbuser <- \"polconfdb_4\"\n  dbhost <- \"moodledb.cms.hu-berlin.de\"\n  dbport <- \"5432\"\n  dbpass <- \"Zs%7f_+9;hcRRw\"\n  \n  # connect to PostgreSQL Server\n  drv <- dbDriver(\"PostgreSQL\") \n  con <- dbConnect(drv, host=dbhost, port=dbport, dbname=dbname, user=dbuser, password=dbpass) \n\n  # remove parameter objects\n  rm(list=(ls()[grepl(\"[db.{4}]\",ls())]))\n\n# (2) Read data tables\n  # get dataframe with columns in TABLES in beta_version schema \n  ColumnsInTables <- dbGetQuery(con,\"SELECT table_catalog, table_schema, table_name, column_name, ordinal_position, data_type \n                        FROM information_schema.columns\n                        WHERE table_schema = 'beta_version'\n                        AND table_name NOT LIKE 'view_%';\")\n  head(ColumnsInTables)\n  # list tables ...\n  TABLES <- sort(unique(ColumnsInTables$table_name))\n  TABLES <- TABLES[!grepl(\"update_|matview|pview\",TABLES)]  \n    \n    # ... and read Tables in beta_version schema into dataframes \n    for (i in 1:length(TABLES)) {\n      assign(TABLES[i], dbReadTable(con, c(\"beta_version\",TABLES[i])))\n    }\n\n  # get dataframe with columns in VIEWS in beta_version schema\n  ColumnsInViews <- dbGetQuery(con,\"SELECT table_catalog, table_schema, table_name, column_name, ordinal_position, data_type \n                        FROM information_schema.columns\n                                WHERE table_schema = 'beta_version'\n                                AND table_name LIKE '%view_%';\")\n  head(ColumnsInViews)\n  # list views ...\n  VIEWS <-  sort(unique(ColumnsInViews$table_name))\n  VIEWS <-  VIEWS[!grepl(\"matview\",VIEWS)] \n  \n    # ... and read Views in beta_version schema into dataframes \n    for (i in 1:length(VIEWS)) {\n      assign(gsub(\"../shiny-experiments/view_configuration_vto\",\"vto\",VIEWS)[i], dbReadTable(con, c(\"beta_version\",VIEWS[i])))\n    }  \n  \n  # before proceeding, disconnect from database  \n  dbDisconnect(con)\n  rm(con)\n  \n# (3) Create list with all countries in PCDB for selector-input choice \n  # get country ISO-character codes\n  countrySelectorList <- rbind( \"All\" , country[,c(\"ctr_ccode2\",\"ctr_ccode\")] )  \n  # use countrycode package to asign country names to all but first row names\n  rownames(countrySelectorList)[-1] <- countrycode(countrySelectorList[-1,1],\"iso2c\",\"country.name\") \n  # name first row manually\n  rownames(countrySelectorList)[1] <- \"All countries\"\n  # define as list with country names as first-dimension names, and ISO-3-character codes as elements\n  countrySelectorList <- as.list( apply(countrySelectorList[], 1,  function( e ) e = e[2]) )\n\n# (4) Create list with column-label lists for later labeling of input-selector choices\n  # load dataframe with all codes and descriptive labels  \n  AbbrLabs <- read.csv(\"AbbrLabs.csv\",sep=\",\")[,c(\"abbr\",\"label\")]\n   \n  # create empty list\n  colLabsList <- list()\n  # and fill with lists that have code as character string as elements, and 'descriptive label (code)' as first-dimension names\n  for (i in seq_along(TABLES)) {\n    A <- unique( AbbrLabs[  AbbrLabs$abbr %in% names(get(TABLES[i])), ] )\n    B <- apply(A, 1,  function( c )  c[2]= c[1]) \n    names(B) <- paste0(A[,2],\" (\",A[,1],\")\")\n    B <- as.list(B)\n    colLabsList[[i]] <-  B\n    rm(A,B)\n  }; rm(i)\n  # name first dimension of column-labels list \n  names(colLabsList) <- paste0(tolower(TABLES))\n    # this allows referncing as 'colLabsList$foo' (i.e., list dollar-sign table name)\n\n  # Example: now one can get a named list with column descriptions ...\n    # for instance, for the first four columns of the country table,\n    colLabsList$country[colLabsList$country %in% colnames(country)[1:4] ]\n\n    # or for the columns of a merge of the country table with the cabinet table\n    ccv <- merge(country[,1:4],cabinet,by=\"ctr_id\",type=\"right\")\n    ccv_labs <- append(colLabsList$country [colLabsList$country %in% colnames(country)[1:4] ], \n                       colLabsList$cabinet[ -grep(\"ctr_id\",colLabsList$cabinet) ] ) \n    # NOTE that by default elements that occur in both lists, i.e., are duplicated\n    # (e.g, 'Country identifier (ctr_id)' appears in both lists) are only represented once\n    ccv_labs\n    \n    all(TRUE== ( colnames(ccv) %in% ccv_labs ) )  # check: works\n    # clean up\n    rm(list=(ls()[grepl(\"ccv.*\",ls())]))\n\n# (5) Cache list with all objects required for webpages with key=list(\"PCDB\", \"data\")\n  allPCDBObjects <- lapply(ls(.GlobalEnv, all.names = F), function(o) get(o, envir = .GlobalEnv)) \n\n  names(allPCDBObjects) <- ls(.GlobalEnv, all.names = F)[!grepl(\"allPCDBObjects\",ls())]\n  \n  if ( sub(\".*/\",\"\",getwd()) == \"vaps-dashboard_public\" ) {\n    setCacheRootPath(path=getwd()) \n    saveCache(allPCDBObjects, key=list(\"PCDB\",\"data\"))   \n  } else warning(\"Cannot cache list. Please setwd() or setCacheRootPath() to vaps-dashboard_public directory!\")\n  \n  rm(allPCDBObjects)\n    \n\n  ",
    "created" : 1472118747072.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3668886474",
    "id" : "C529A806",
    "lastKnownWriteTime" : 1472117964,
    "path" : "~/Documents/Humboldt/Electoral_Vulnerability/Projects/vaps-dashboard_public/databaseAccessHauke.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}