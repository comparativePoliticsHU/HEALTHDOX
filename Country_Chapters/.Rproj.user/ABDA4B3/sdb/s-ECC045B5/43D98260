{
    "contents" : "matchEventsOnConfigs <- function(\n  events,  # vector with event dates or date frame, where observations are identified by events-within-countries\n  config_ts,  # configuration time-series, is data frame with attributes start_date and (optionally) group_id \n  start_date_var,  # variable that has configuration start dates\n  event_dates_col = NULL,  #  variable has event dates\n  group_var = NULL # variable that identifies groups in configuration time series \n) {\n\n# config_ts: configuration time-series, is data frame with attributes group_id and start_date\n  options(warn=-1)\n  if (!require('dplyr')) install.packages(\"dplyr\") \n  \n  if ( !( class(events) == \"data.frame\" || is.null(dim(events)) ) ) stop(\"Input to 'events' argument must be a vector or data frame!\",\"\\n\")\n  if ( !( class(config_ts) == \"data.frame\" ) ) stop(\"Input to 'config_ts' argument must be a data frame!\",\"\\n\")\n  if ( !( class(config_ts[, start_date_var]) == \"Date\" ) ) stop(\"start_date_var must have format date!\",\"\\n\")\n  \n  # compute configuration end dates\n  if ( !is.null(group_var) ) {\n    names(config_ts)[ names(config_ts) %in% start_date_var ] <- \"start_date\"\n    names(config_ts)[ names(config_ts) %in% group_var ] <- \"group_id\"\n    \n  config_ts <- config_ts %>% \n    arrange(group_id, start_date) %>% \n    group_by(group_id) %>% \n    mutate(end_date = lead(start_date-1) ) %>%   \n    ungroup %>%\n    as.data.frame()\n  } else {\n    names(config_ts)[ names(config_ts) %in% start_date_var ] <- \"start_date\"\n    config_ts <- config_ts %>% \n      arrange(start_date) %>% \n      mutate(end_date = lead(start_date-1) ) %>%  \n      ungroup %>%\n      as.data.frame()\n  }\n\n  # match event dates to configurations \n  if ( is.null(dim(events)) && typeof(events)!=\"list\" ) {  # if input to events argument is a vector\n    occured <- lapply(seq_along(events), function(e) {\n      subsetter <- ifelse( is.na(config_ts$end_date), \n                           (config_ts$start_date<=events[e]), \n                           (config_ts$start_date<=events[e] & config_ts$end_date>=events[e])\n                          )\n      if ( any(subsetter) ) {\n        df <- subset(config_ts, subset = subsetter)\n        df <- cbind(event_date=events[e],df)\n      }\n    })\n    # names(occured) <- paste(\"event\",seq_along(events),sep=\"\")\n  } else if ( length(dim(events)) == 2L ) { # if input to events argument is a data frame\n#    config_ts <- as.data.frame(config_ts)\n    \n    names(events)[ names(events) %in% event_dates_col ] <- \"event_date\"\n    names(events)[ names(events) %in% group_var ] <- \"group_id\"\n    \n    joiner <- merge(events,config_ts,by=\"group_id\",all=T)\n    \n    group_ids <- unique(joiner[, \"group_id\"])\n    occured <- lapply(seq_along(group_ids), function(g) {\n      subset(subset(joiner,group_id==group_ids[g]), \n             ifelse( is.na(end_date), \n                     (start_date<=event_date), \n                     (start_date<=event_date & end_date>=event_date)\n                   )\n      )\n    })\n  }\n  \n  if ( !missing(group_var) ) {\n    occured <- occured %>%\n      do.call(rbind,.) %>%\n      arrange(group_id, event_date) %>% \n      as.data.frame()\n  } else {\n    occured <- occured %>%\n      do.call(rbind,.) %>%\n      arrange(event_date) %>% \n      as.data.frame()\n  }\n  \n  names(occured)[ names(occured) %in% \"group_id\" ] <- group_var\n  names(occured)[ names(occured) %in% \"start_date\" ] <- start_date_var\n  names(occured)[ names(occured) %in% \"event_date\" ] <- event_dates_col\n  \n  options(warn=0)\n  occured\n  \n}\n  ",
    "created" : 1472024843324.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "984147495",
    "id" : "43D98260",
    "lastKnownWriteTime" : 1472042603,
    "path" : "~/Documents/Humboldt/HEALTHDOX/Country_Chapters/jobs/matchEventsOnConfigs.R",
    "project_path" : "jobs/matchEventsOnConfigs.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}